#ifdef IN_IDE_PARSER
#include "convert.h++"
#endif

#include <string>
#include <iomanip>
#include <sstream>

#include <boost/asio.hpp>

#include <boost/serialization/split_free.hpp>
#include <boost/serialization/vector.hpp>

template <typename InputInterator>
inline std::string to_hex(InputInterator begin, InputInterator end, bool uppercase) {
	using namespace std;

	stringstream ss;
	ss << hex << setfill('0');
	if (uppercase)
		ss << std::uppercase;
	std::for_each(begin, end, [&](auto x) { ss << setw(2) << int(x); });

	return ss.str();
}

template <typename _CharT, typename _Traits>
inline std::basic_istream<_CharT, _Traits>& operator>>(std::basic_istream<_CharT, _Traits>& s, boost::asio::ip::address& a) {
	std::string str;
	s >> str;
	a.from_string(str);
	return s;
}

template <typename _CharT, typename _Traits>
inline std::basic_istream<_CharT, _Traits>& operator<<(std::basic_istream<_CharT, _Traits>& s, boost::asio::ip::address& a) {
	s << a.to_string();
	return s;
}

template <typename InputInterator>
inline boost::asio::ip::address hex_to_address(InputInterator begin, InputInterator end) {
	std::string str(to_hex(begin, end), false);
	for (std::size_t idx(4); idx < str.length(); idx += 5)
		str.insert(idx, ":");
	str.replace(0, 2, "fc");	
	
	return boost::asio::ip::address::from_string(str);
}

template <typename T>
inline  boost::asio::ip::address hex_to_address(std::vector<T> const& v) {
	if (v.size() > 16)
		return hex_to_address(end(v)-16, end(v));
	return hex_to_address(begin(v), end(v));
}

namespace boost {
namespace serialization {

template <typename Archive, typename InternetProtocol>
inline void save(Archive& ar, boost::asio::ip::basic_endpoint<InternetProtocol> const& e, unsigned int const) {
	// serialization needs to be done from local variable
	auto address(e.address().to_string());
	auto port(e.port());
	ar << address;
	ar << port;
}

template <typename Archive, typename InternetProtocol>
inline void load(Archive& ar, boost::asio::ip::basic_endpoint<InternetProtocol>& e, unsigned int const) {
	// read value from stream
	std::string address;
	short unsigned int port;

	ar >> address;
	ar >> port;
	//e = boost::asio::ip::udp::endpoint(boost::asio::ip::address::from_string(address), port);
}

template <typename Archive, typename InternetProtocol>
inline void serialize(Archive& ar, boost::asio::ip::basic_endpoint<InternetProtocol>& e, unsigned int const file_version){
	split_free(ar, e, file_version);
}

} // namespace: serialization
} // namespace: boost
