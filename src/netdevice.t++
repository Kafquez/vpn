#ifdef IN_IDE_PARSER
#include "netdevice.h++"
#endif

#include "convert.h++"
#include "program_options.h++"
#include <boost/asio/ip/udp.hpp>
#include <boost/asio/posix/stream_descriptor.hpp>
#include <algorithm>
#include <cstdlib>
#include <string>
#include <cerrno>
#include <functional>
#include <system_error>
#include <linux/if_tun.h>
#include <linux/ipv6_route.h>
#include <iomanip>
#include <thread>
#include <utility>
#include <memory>

template <typename Server>
inline netdevice<Server>::netdevice(boost::asio::io_service& io, std::string name) :
	io_(io),
	strand_(io_),
	name_(name),
	stream_descriptor_(io_)
{
	using namespace std;

	// open device
	auto fd(::open("/dev/net/tun", O_RDWR));
	if (fd < 0)
		throw system_error(errno, system_category(), "Could not open tun/tap control device");
	stream_descriptor_.assign(fd);

	// do some io control
	ifreq req({});
	req.ifr_ifru.ifru_flags = IFF_TUN | IFF_NO_PI;
	name_.copy(req.ifr_name, IFNAMSIZ);
	ioctl set(TUNSETIFF, &req);
	stream_descriptor_.io_control(set);
	name_ = req.ifr_name;
// 	needs to be reassigned after this specific ioctl
	stream_descriptor_.release();
	stream_descriptor_.assign(fd);
	stream_descriptor_.native_non_blocking(true);
	
	std::cerr << "______________IS OPEN : " << stream_descriptor_.is_open() << "_________ fd: " << fd << std::endl;

	// calculate address from fingerprint
// // 	stringstream add;
// // 	auto finger(to_hex(gateway_.fingerprint().data(), gateway_.fingerprint().size()));
// // 	add << "fc" << finger[10] << finger[11] << ":"
// // 		<< finger[12] << finger[13] << finger[14] << finger[15] << ":"
// // 		<< finger[16] << finger[17] << finger[18] << finger[19] << ":"
// // 		<< finger[20] << finger[21] << finger[22] << finger[23] << ":"
// // 		<< finger[24] << finger[25] << finger[26] << finger[27] << ":"
// // 		<< finger[28] << finger[29] << finger[30] << finger[31] << ":"
// // 		<< finger[32] << finger[33] << finger[34] << finger[35] << ":"
// // 		<< finger[36] << finger[37] << finger[38] << finger[39];
// //
// // 	// route up and go
// // 	address(boost::asio::ip::address_v6::from_string(add.str()));
	
	system(string("ifconfig " + name_ + " up add fc45:7f3:398a:6e1f:8e7::4/8").data());
	
// 	address(boost::asio::ip::address_v6::from_string("fc44:07f3:398a:6e1F:08e7:7756:ff39:029e"));
// 	route(boost::asio::ip::address_v6::from_string("fc::"), 64);
// 	up();
// 	mtu(1280);
}

template <typename Server>
inline void netdevice<Server>::startup() {
	std::cerr << __FILE__ << " " << __LINE__ << " " << __FUNCTION__ << std::endl;
	accept();
}

template <typename Server>
inline netdevice<Server>::~netdevice() noexcept {
	stream_descriptor_.close();
}

template <typename Server>
inline void netdevice<Server>::up() {
	using namespace boost::asio;

	io_service io;
	ifreq req({});
	name_.copy(req.ifr_name, IFNAMSIZ);
	ip::udp::socket socket(io, ip::udp::v4());
	ioctl get(SIOCGIFFLAGS, &req);
	socket.io_control(get);
	req.ifr_flags |= IFF_UP;
	ioctl set(SIOCSIFFLAGS, &req);
	socket.io_control(set);
}

template <typename Server>
inline bool netdevice<Server>::is_up() const {
	using namespace boost::asio;

	io_service io;
	ifreq req({});
	name_.copy(req.ifr_name, IFNAMSIZ);
	ip::udp::socket socket(io, ip::udp::v4());
	ioctl get(SIOCGIFFLAGS, &req);
	socket.io_control(get);
	return req.ifr_flags & IFF_UP;
}

template <typename Server>
inline void netdevice<Server>::mtu(unsigned int mtu) {
	using namespace boost::asio;

	io_service io;
	ifreq req({});
	name_.copy(req.ifr_name, IFNAMSIZ);
	ip::udp::socket socket(io, ip::udp::v4());
	req.ifr_mtu = mtu;
	ioctl set(SIOCSIFMTU, &req);
	socket.io_control(set);
}

template <typename Server>
inline unsigned int netdevice<Server>::mtu() const {
	using namespace boost::asio;

	io_service io;
	ifreq req({});
	name_.copy(req.ifr_name, IFNAMSIZ);
	ip::udp::socket socket(io, ip::udp::v4());
	ioctl get(SIOCGIFMTU, &req);
	socket.io_control(get);
	return req.ifr_mtu;
}

// template <typename Server>
// inline void netdevice<Server>::address(boost::asio::ip::address const& address) {
// 	if (address.is_v4())
// 		address(address.to_v4());
// 	else
// 		address(address.to_v6());
// }

// template <typename Server>
// inline void netdevice<Server>::address(boost::asio::ip::address_v4 const& address) {
// 	using namespace boost::asio;
//
// 	io_service io;
// 	ifreq req({});
// 	name_.copy(req.ifr_name, IFNAMSIZ);
// 	ip::udp::socket socket(io, ip::udp::v4());
// 	ip::udp::endpoint end;
// 	end.address(address);
// 	std::copy_n(end.data(), 1, &req.ifr_addr);
// //	std::copy_n(&reinterpret_cast<detail::sockaddr_in4_type*>(end.data())->sin6_addr, 1, &req.ifr_addr);
// 	ioctl set(SIOCSIFADDR, &req);
// 	socket.io_control(set);
// }

template <typename Server>
inline void netdevice<Server>::address(boost::asio::ip::address_v6 const& address) {
	using namespace std;
	using namespace boost::asio;

	// from linux/ipv6.h
	struct in6_ifreq {
		struct in6_addr ifr6_addr;
		__u32           ifr6_prefixlen;
		int             ifr6_ifindex;
	};

	io_service io;
 	in6_ifreq if6req({});
	if6req.ifr6_prefixlen = 128;
	if6req.ifr6_ifindex = ifindex();
	ip::udp::endpoint end;
	end.address(address);
	std::copy_n(&reinterpret_cast<detail::sockaddr_in6_type*>(end.data())->sin6_addr, 1, &if6req.ifr6_addr);
	ip::udp::socket socket6(io, ip::udp::v6());
	ioctl set(SIOCSIFADDR, &if6req);
	socket6.io_control(set);
}

template <typename Server>
inline int netdevice<Server>::ifindex() const {
	using namespace std;
	using namespace boost::asio;

	io_service io;
	ifreq req({});
	name_.copy(req.ifr_name, IFNAMSIZ);
	ip::udp::socket socket4(io, ip::udp::v4());
	ioctl get(SIOCGIFINDEX, &req);
	socket4.io_control(get);
	return req.ifr_ifindex;
}

template <typename Server>
inline void netdevice<Server>::route(boost::asio::ip::address_v6 const&, std::uint8_t const prefix) {
	using namespace std;

	system(string("ip -6 route add fc00::/8 metric 64 dev " + name_).data());

	//io_service io;
	//in6_rtmsg route({});
}

template <typename Server>
inline void netdevice<Server>::accept() {
	using namespace std;
	using namespace placeholders;

	auto buffer(make_shared<vector<uint8_t>>());
	buffer->resize(4096);
	
	stream_descriptor_.async_read_some(boost::asio::buffer(*buffer, 4096), bind(&netdevice<Server>::read, this, buffer, _1, _2));
	std::cerr << __FILE__ << " " << __LINE__ << " " << __FUNCTION__ << " :::: size: " << std::endl;
}


template <typename Server>
inline void netdevice<Server>::send(boost::asio::const_buffers_1 b) {
	boost::asio::write(stream_descriptor_, b);
}

template <typename Server>
inline void netdevice<Server>::read(std::shared_ptr<std::vector<std::uint8_t>> buffer, boost::system::error_code const& error, std::size_t bytes_transferred) {
	using namespace std;
	
	std::cerr << __FILE__ << " " << __LINE__ << " " << __FUNCTION__ << " buffercapa: " << buffer->capacity() << " buffersize: " << buffer->size() << std::endl;


	std::cerr << "______________________________________________ READ NET __________________________________" << error << " :: " << bytes_transferred << std::endl;

	// TODO: check for errors
	if (error)
		return;

	std::cerr << "______________________________________________ READ NET 2__________________________________" << error << std::endl;
	
// 	if (bytes_transferred == 0)
// 		return;

	accept();

// 	gateway_.forward(boost::asio::buffer(const_cast<const uint8_t*>(buffer->data()), bytes_transferred));
}

template <typename Server>
inline std::string const& netdevice<Server>::name() noexcept {
	return name_;
}

template <typename Server>
inline netdevice<Server>::ioctl::ioctl(int const name, void *data) : name_(name), data_(data) {
}

template <typename Server>
inline int netdevice<Server>::ioctl::name() const {
	return name_;
}

template <typename Server>
inline void* netdevice<Server>::ioctl::data() {
	return data_;
}


